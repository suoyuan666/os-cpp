// -*- C++ -*-
#pragma once

#include <cstdint>
#include <type_traits>

#include "console.h"
#include "lock.h"

namespace fmt {

static struct {
  class lock::spinlock lock{};
  bool locked{true};
} pr;

auto puts(const char *str) -> void;

template <typename T>
void format_arg(char *buffer, uint32_t size, const T &arg,
                bool is_hex = false) {
  if constexpr (std::is_integral_v<T>) {
    if (size < 2) {
      if (size >= 1) buffer[0] = '\0';
      puts(buffer);
      return;
    }

    char *end = buffer + size - 1;
    *end = '\0';
    char *ptr = end - 1;

    using UnsignedType = std::make_unsigned_t<T>;
    UnsignedType unsigned_value;
    bool neg = false;

    if constexpr (std::is_signed_v<T>) {
      neg = (arg < 0);
      unsigned_value = neg ? static_cast<UnsignedType>(-arg)
                           : static_cast<UnsignedType>(arg);
    } else {
      unsigned_value = arg;
    }

    if (unsigned_value == 0) {
      buffer[0] = '0';
      buffer[1] = '\0';
      puts(buffer);
      return;
    }

    if (is_hex) {
      constexpr char hex_digits[] = "0123456789abcdef";
      while (unsigned_value > 0 && ptr >= buffer) {
        *ptr-- = hex_digits[unsigned_value & 0xF];
        unsigned_value >>= 4;
      }
    } else {
      while (unsigned_value > 0 && ptr >= buffer) {
        *ptr-- = '0' + (unsigned_value % 10);
        unsigned_value /= 10;
      }
    }

    if (neg && ptr >= buffer) {
      *ptr-- = '-';
    }

    char *start = ptr + 1;
    puts(start);

  } else if constexpr (std::is_same_v<T, const char *> ||
                       std::is_same_v<T, char *>) {
    if (size == 0) {
      return;
    }
    if (!arg) {
      buffer[0] = '\0';
      puts("");
      return;
    }

    size_t len = 0;
    while (len < size - 1 && arg[len] != '\0') {
      buffer[len] = arg[len];
      len++;
    }
    buffer[len] = '\0';
    puts(buffer);
  } else {
    static_assert(std::is_integral_v<T> || std::is_same_v<T, const char *> ||
                      std::is_same_v<T, char *>,
                  "unsupported type for format_arg");
  }
}

template <typename... Args>
void print_format(const char *&fmt, Args... args);

auto print_format(const char *fmt) -> void;

template <typename First, typename... Next>
auto print_format(const char *&fmt, First first, Next... next) -> void {
  while (fmt != nullptr && *fmt != '\0') {
    if (*fmt == '{' && (fmt + 1) != nullptr &&
        (*(fmt + 1) == '}' ||
         ((fmt + 2) != nullptr && *(fmt + 1) == 'x' && *(fmt + 2) == '}'))) {
      char buffer[32];
      bool is_hex = (*(fmt + 1) == 'x');
      format_arg(buffer, sizeof(buffer), first, is_hex);
      if (is_hex) {
        fmt += 3;
      } else {
        fmt += 2;
      }
      if constexpr (sizeof...(next) > 0) {
        print_format(fmt, next...);
      } else {
        puts(fmt);
        while (fmt != nullptr && *fmt != '\0') {
          ++fmt;
        }
        return;
      }
    } else {
      console::putc(*fmt);
      ++fmt;
    }
  }
}

template <typename... Args>
auto print(const char *fmt, Args... args) -> void {
  auto locked = pr.locked;
  if (locked) {
    pr.lock.acquire();
  }
  print_format(fmt, args...);
  if (locked) {
    pr.lock.release();
  }
}

auto print(const char *str) -> void;

auto panic(const char *str) -> void;

enum log_level : uint8_t {
  INFO,
  DEBUG,
  WARNNING,
  ERROR,
};

auto print_log(log_level level, const char *msg) -> void;
}  // namespace fmt
