// -*- C++ -*-
//
#include <cstdint>
#include <optional>

#include "arch/riscv"

namespace vm {
extern "C" char trampoline[];
extern "C" char end[];
// qemu -machine virt is set up like this,
// based on qemu's hw/riscv/virt.c:
//
// 00001000 -- boot ROM, provided by qemu
// 02000000 -- CLINT
// 0C000000 -- PLIC
// 10000000 -- uart0
// 10001000 -- virtio disk
// 80000000 -- boot ROM jumps here in machine mode
//             -kernel loads the kernel here
// unused RAM after 80000000.

// the kernel uses physical memory thus:
// 80000000 -- entry.S, then kernel text and data
// end -- start of kernel page allocation area
// PHYSTOP -- end RAM used by the kernel

constexpr uint64_t UART0{0x10000000ULL};
constexpr uint64_t UART_IRQ{10ULL};

constexpr uint64_t VIRTIO0{0x10001000ULL};
constexpr uint64_t VIRTIO_IRQ{1ULL};

constexpr uint64_t PLIC{0x0c000000ULL};
constexpr uint64_t PLIC_PRIORITY{PLIC + 0x0};
constexpr uint64_t PLIC_PENDING{PLIC + 0x1000};
constexpr auto PLIC_SENABLE = [](uint64_t hart) -> uint64_t {
  return PLIC + 0x2080 + (hart) * 0x100;
};
constexpr auto PLIC_SPRIORITY = [](uint64_t hart) -> uint64_t {
  return PLIC + 0x201000 + (hart) * 0x2000;
};
constexpr auto PLIC_SCLAIM = [](uint64_t hart) -> uint64_t {
  return PLIC + 0x201004 + (hart) * 0x2000;
};

constexpr uint64_t KERNEL_BASE{0x80000000ULL};
constexpr uint64_t PHY_END{KERNEL_BASE + 128ULL * 1024ULL * 1024ULL};

constexpr uint64_t TRAMPOLINE{VA_MAX - PGSIZE};
constexpr uint64_t TRAMFRAME{TRAMPOLINE - PGSIZE};
constexpr auto KSTACK = [](uint64_t pa) -> uint64_t {
  return TRAMFRAME - (pa + 1) * 2 * PGSIZE;
};

class kernel_vm {
  struct list {
    struct list *next;
  };
  struct list *freelist{};

 public:
  kernel_vm() {
    for (auto p_start = (uint64_t)end; p_start != PHY_END; p_start += PGSIZE) {
      free(reinterpret_cast<void *>(p_start));
    }
  }

  auto free(void *addr) -> void {
    auto *tmp = static_cast<struct list *>(addr);
    tmp->next = freelist;
    freelist = tmp;
  }
  auto alloc() -> std::optional<uint64_t *> {
    auto *tmp = freelist;
    if (tmp) {
      freelist = tmp->next;
      auto rs_val = reinterpret_cast<uint64_t *>(tmp);
      return {rs_val};
    }
    return {};
  }
};

static kernel_vm kevm{};

auto init() -> void;
auto map_pages(uint64_t *pagetable, uint64_t va, uint64_t pa, uint64_t size,
               uint32_t flag) -> bool;
auto inithart() -> void;
auto uvm_alloc() -> uint64_t *;
auto uvm_first(uint64_t *pagetable, unsigned char *src, uint32_t size) -> void;
auto uvm_unmap(uint64_t *pagetable, uint64_t va, uint64_t npages, bool do_free)
    -> void;
auto uvm_free(uint64_t *pagetable, uint64_t sz) -> void;
auto uvm_dealloc(uint64_t *pagetable, uint64_t oldsz, uint64_t newsz)
    -> uint64_t;
auto uvm_alloc(uint64_t *pagetable, uint64_t oldsz, uint64_t newsz, int xperm)
    -> uint64_t;
auto copyin(uint64_t *pagetable, char *dst, uint64_t srcva, uint64_t len)
    -> bool;
auto copyout(uint64_t *pagetable, uint64_t dstva, char *src, uint64_t len)
    -> bool;
auto uvm_copy(uint64_t *old_pagetable, uint64_t *new_pagetable, uint64_t sz)
    -> bool;
}  // namespace vm
